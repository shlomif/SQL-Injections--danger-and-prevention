#include "shlomif-shlomif-article.wml"
<article_subject "SQL Injections" />
<article_description "SQL Injections - why are they dangerous and how to avoid them" />
<article_keywords "SQL, injections, database, security" />

<h2 id="intro">Introduction</h2>

<p>
<a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection</a> is
a common form of vulnerability in applications that work against SQL databases.
This article will explain what SQL injections are, why they are dangerous
and give some advice on how to avoid them
</p>

<h2 id="what_are_sql_injections">What are SQL Injections?</h2>

<p>
Let's suppose we have the following table definition in an 
<a href="http://www.sqlite.org/">SQLite</a> database with the filename of
<tt>injection1.db</tt>:
</p>

<pre>
CREATE TABLE names (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR (255)
);
</pre>

<p>
Let's say we've written a program to insert a new name into the
<tt>names</tt> table like so:
</p>

<pre>
print( "Enter a name to insert:\n" )
name = input()
db = SQLite3::Database.new( "injection1.db" )
db.execute_batch( 
           "INSERT INTO names (id, name) VALUES (null, " + name + ")" 
          )
</pre>

<p>
(It's written in <a href="http://www.ruby-lang.org/en/">Ruby</a>, but should 
be easy to understand for people who are not familiar with it.)
</p>

<p>
As one can see this program passes the name directly as the field argument
in the SQL. It works if we enter a number:
</p>

<pre>
$ ruby insert-without-quotes.rb
Enter a name to insert:
180
$
</pre>

<p>
But if we try to insert some letters, we get: 
</p>

<pre>
$ ruby insert-without-quotes.rb
Enter a name to insert:
Jake
/usr/lib/ruby/site_ruby/1.8/sqlite3/errors.rb:62:in `check': no such column: Jake (SQLite3::SQLException)
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/statement.rb:39:in `initialize'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `new'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `prepare'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:181:in `execute'
        from insert-without-quotes.rb:7
</pre>

<p>
The important thing here is the "no such column" error that we get from 
SQLite. What happens is that the SQL backend does not know how to understand
the barewords. Therefore, we must enclose the string in the SQL standard
single quotes (<tt>'â€¦'</tt>). This makes our code the following:
</p>

<pre>
print( "Enter a name to insert:\n" )
name = input()

db = SQLite3::Database.new( "injection1.db" )
db.execute_batch( 
    "INSERT INTO names (id, name) VALUES (null, " + "'" + name + "'" + ")" 
)
</pre>

<p>
This seems to work fine:
</p>

<pre>
$ ruby insert-with-quotes.rb
Enter a name to insert:
Jake
$ ruby insert-with-quotes.rb
Enter a name to insert:
Sophie
$ sqlite3 injection1.db
SQLite version 3.6.11
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; SELECT * FROM names ;
1|Jake
2|Sophie
</pre>

<p>
But is it really bullet-proof? Notice that we inserted the name field directly
into the SQL. What will happen if it contains single-quotes that terminate 
the string prematurely. The answer is that in case it may either simply fail:
</p>

<pre>
$ ruby insert-with-quotes.rb
Enter a name to insert:
Ralph O'Henry
/usr/lib/ruby/site_ruby/1.8/sqlite3/errors.rb:62:in `check': near "Henry": syntax error (SQLite3::SQLException)
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/statement.rb:39:in `initialize'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `new'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `prepare'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:181:in `execute'
        from insert-with-quotes.rb:14
</pre>

<p>
But since we can terminate the string, and then proceed to insert arbitrary
SQL, it could be much worse:
</p>

<pre>
$ ruby insert-with-quotes.rb
Enter a name to insert:
a');DROP TABLE names; SELECT * FROM data WHERE (name LIKE '%
/usr/lib/ruby/site_ruby/1.8/sqlite3/errors.rb:62:in `check': no such table: data (SQLite3::SQLException)
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/statement.rb:39:in `initialize'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `new'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:154:in `prepare'
        from /usr/lib/ruby/site_ruby/1.8/sqlite3/database.rb:225:in `execute_batch'
        from insert-with-quotes.rb:14
</pre>

<p>
And now if we look at the database, we'll see that the "names" table have
been dropped! What happened? Due to the way the SQL portion was inserted 
directly between the quotes, our query has become the following:
</p>

<pre>
INSERT INTO names (id, name) VALUES (null, 'a');
DROP TABLE names;
SELECT * FROM data WHERE (name LIKE '%')
</pre>

<p>
These are in fact three SQL statements grouped into one: the first inserts
a dummy value into names. The second drops the table, and the third forms
a well-formed query that will be compilable by strict SQL engines but that
would in fact just serve to terminate the rest of the query passed
by the code.
</p>

<p>
Even if the interface to the database did not allow us to execute as many 
statements as we'd like, then SQL injection attacks can still do a lot of 
damage. For example the following example taken from <a href="http://en.wikipedia.org/wiki/SQL_injection">the wikipedia page about SQL injections</a>:
</p>

<p>
With the code:
</p>

<pre>
statement = "SELECT * FROM users WHERE name = '" + userName + "';"
</pre>

<p>
And the following value of the userName variable:
</p>

<pre>
a' or 't'='t
</pre>

<p>
Then the query becomes:
</p>

<pre>
SELECT * FROM users WHERE name = 'a' OR 't'='t';
</pre>

<p>
And as such the WHERE condition always evaluates to true, bypassing potential
security measurements.
</p>
